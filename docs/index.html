<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>K-Movie A Archive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="assets/style.css" />
  <style>
    .hdr { display:flex; gap:12px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    .hdr .sp { flex:1; }
    .pill { font-size:12px; color:#666; background:#f3f4f6; border:1px solid #e5e7eb; padding:4px 8px; border-radius:999px; }
    .monthbar { display:flex; align-items:center; gap:8px; margin:10px 0 8px; }
    .day-list { display:flex; flex-wrap:wrap; gap:6px; }
    .day-btn {
      min-width:28px; text-align:center; padding:4px 6px;
      border:1px solid var(--bd); border-radius:12px; background:#fff; cursor:pointer;
    }
    .day-btn.hasMovies { outline:2px solid var(--accent); }
    .note { color:#666; font-size:13px; margin-top:4px; }
    .list { margin-top:10px; }
    .row { padding:8px 0; border-bottom:1px solid #eee; }
    .row a { font-weight:600; }
    .muted { color:#666; font-size:13px; }
  </style>
</head>
<body>
<div class="container">
  <div class="hdr">
    <h1>K-Movie A Archive</h1>
    <div class="sp"></div>
    <a class="btn" href="index.html">홈</a>
    <a class="btn" href="search.html">영화 검색</a>
    <a class="btn" href="people-search.html">배우 검색</a>
    <a class="btn" href="saved.html">저장 목록</a>
  </div>

  <div class="pill" id="rangePill">데이터 범위: 로딩 중…</div>

  <h2 style="margin:12px 0 8px;">월간 타임라인</h2>
  <div class="monthbar">
    <button class="btn" id="prevM">◀ 이전 달</button>
    <div id="ymLabel" style="font-weight:700;"></div>
    <button class="btn" id="nextM">다음 달 ▶</button>
  </div>

  <div class="tl-bar" id="tlBar"></div>
  <div class="tl-panel" id="panel">날짜를 선택하면 해당 날짜의 개봉작을 보여줍니다.</div>
  
  <div id="boxoffice-container" style="margin-top: 30px;"></div>
</div>

<script>
// --- 타임라인 기능 관련 스크립트 ---
const MOVIE_INDEX_URL = 'data/search/movies.json';

// YYYYMMDD 형식인지 검사하는 함수는 그대로 둠
const isYmd8 = (s) => /^\d{8}$/.test(String(s||'').trim());

function ymParts(ym){ return [ym.getFullYear(), ym.getMonth()+1]; }
function pad2(n){ return String(n).padStart(2,'0'); }
function daysInMonth(y,m){ return new Date(y, m, 0).getDate(); } // m: 1~12

let MOVIES = [];
let YM = new Date();

// [핵심 수정] 데이터를 읽을 때 날짜 형식(YYYY-MM-DD)을 YYYYMMDD로 정규화하는 과정 추가
function pickValidMovies(src){
  if (!src || !Array.isArray(src.movies)) return [];
  
  return src.movies.map(m => {
    // 원본 openDt를 기반으로 하이픈(-)을 제거한 openDt_normalized 필드를 새로 추가
    m.openDt_normalized = (m.openDt || '').replace(/-/g, '');
    return m;
  }).filter(m => isYmd8(m.openDt_normalized)); // 정규화된 날짜 필드로 유효성 검사
}

function computeRange(arr){
  if (!arr.length) return null;
  let minY = 9999, maxY = 0;
  for (const m of arr){
    // 정규화된 날짜 필드를 사용
    const y = parseInt(m.openDt_normalized.slice(0,4),10);
    if (isFinite(y)){
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }
  }
  if (minY===9999 || maxY===0) return null;
  return {min:minY, max:maxY};
}

function groupByDay(arr, y, m){ // m: 1~12
  const map = {};
  for (let d=1; d<=daysInMonth(y,m); d++) map[d]=[];
  for (const row of arr){
    // 정규화된 날짜 필드를 사용
    const dt = row.openDt_normalized;
    if (!isYmd8(dt)) continue;
    const yy = +dt.slice(0,4);
    const mm = +dt.slice(4,6);
    const dd = +dt.slice(6,8);
    if (yy===y && mm===m && map[dd]) map[dd].push(row);
  }
  return map;
}

function renderMonth(){
  const [y, m] = ymParts(YM);
  document.getElementById('ymLabel').textContent = `${y}년 ${pad2(m)}월`;

  const byDay = groupByDay(MOVIES, y, m);
  const bar = document.getElementById('tlBar');
  bar.innerHTML = '';

  const last = daysInMonth(y, m);
  for (let d=1; d<=last; d++){
    const btn = document.createElement('div');
    btn.className = 'tl-day day-btn' + (byDay[d].length ? ' hasMovies' : '');
    btn.textContent = d;
    btn.title = byDay[d].length ? `${byDay[d].length}편` : '개봉작 없음';
    btn.onclick = ()=> renderPanel(y,m,d, byDay[d]);
    bar.appendChild(btn);
  }

  const today = new Date();
  if (today.getFullYear()===y && (today.getMonth()+1)===m){
    renderPanel(y,m,today.getDate(), byDay[today.getDate()]||[]);
  }else{
    renderPanel(y,m,1, byDay[1]||[]);
  }
}

function renderPanel(y,m,d, list){
  const box = document.getElementById('panel');
  const ymd = `${y}-${pad2(m)}-${pad2(d)}`;
  if (!list || list.length===0){
    box.innerHTML = `<div class="muted">해당 날짜(${ymd})에는 등록된 개봉작이 없습니다.</div>`;
    return;
  }
  const rows = list
    .sort((a,b)=> (a.movieNm || '').localeCompare(b.movieNm||'', 'ko'))
    .map(row=>{
      const badge = row.grade ? `[${row.grade}]` : '';
      const rn = row.repNation || '';
      const gens = Array.isArray(row.genres) ? row.genres.join(', ') : '';
      return `
      <div class="row">
        <a href="detail.html?movieCd=${encodeURIComponent(row.movieCd)}">${row.movieNm||'(제목없음)'}</a>
        <div class="muted">${badge} ${rn} ${gens ? '· '+gens : ''}</div>
      </div>`;
    }).join('');
  box.innerHTML = `<div class="note">${ymd} 개봉작 ${list.length}편</div><div class="list">${rows}</div>`;
}

async function mainTimeline(){
  const res = await fetch(`${MOVIE_INDEX_URL}?v=${Date.now()}`);
  if (!res.ok){
    document.getElementById('rangePill').textContent = '데이터 범위: 인덱스 로드 실패';
    return;
  }
  const js = await res.json();
  MOVIES = pickValidMovies(js);

  const rg = computeRange(MOVIES);
  document.getElementById('rangePill').textContent =
    rg ? `데이터 범위: ${rg.min} – ${rg.max} (인덱스 기준)`
       : '데이터 범위: 비어있음 / 인덱스 재생성이 필요할 수 있음';

  if (MOVIES.length > 0) {
    // 정규화된 날짜 필드를 사용하여 최신 날짜를 찾음
    const latestDateStr = MOVIES.reduce((max, m) => (m.openDt_normalized > max ? m.openDt_normalized : max), '0');
    const year = parseInt(latestDateStr.slice(0, 4), 10);
    const month = parseInt(latestDateStr.slice(4, 6), 10) - 1; 
    if (!isNaN(year) && !isNaN(month)) {
        YM = new Date(year, month);
    }
  }

  renderMonth();

  document.getElementById('prevM').onclick = ()=>{
    YM.setMonth(YM.getMonth()-1);
    renderMonth();
  };
  document.getElementById('nextM').onclick = ()=>{
    YM.setMonth(YM.getMonth()+1);
    renderMonth();
  };
}

// --- 박스오피스 기능 관련 스크립트 ---
async function mainBoxoffice() {
  const container = document.getElementById('boxoffice-container');
  try {
    const ts = Date.now();
    const metaResp = await fetch(`./data/latest.json?v=${ts}`);
    if (!metaResp.ok) throw new Error('latest.json을 찾을 수 없습니다.');
    const meta = await metaResp.json();

    const dataResp = await fetch(`${meta.url}?v=${ts}`);
    if (!dataResp.ok) throw new Error(`데이터 파일(${meta.url})을 찾을 수 없습니다.`);
    const data = await dataResp.json();

    const list = data?.boxOfficeResult?.dailyBoxOfficeList;
    if (Array.isArray(list) && list.length > 0) {
      let html = `<h2>최신 일일 박스오피스 TOP ${Math.min(10, list.length)}</h2>`;
      html += `<div class="note">기준일: ${meta.date}</div>`;
      html += '<ol style="margin:0; padding-left:20px;">'; // UI 유지를 위해 ol 태그에 기본 스타일 추가
      list.slice(0, 10).forEach(item => {
        html += `<li style="padding-left: 5px;">${item.rank}. ${item.movieNm} - ${Number(item.audiCnt).toLocaleString()}명</li>`;
      });
      html += '</ol>';
      container.innerHTML = html;
    }
  } catch (err) {
    console.error('Boxoffice Error:', err);
    container.innerHTML = `<p style="color:red;">박스오피스 정보를 불러오는 데 실패했습니다: ${err.message}</p>`;
  }
}

// --- 스크립트 실행 ---
mainTimeline().catch(e=>{
  console.error('Timeline Error:', e);
  document.getElementById('rangePill').textContent = '데이터 범위: 오류 발생';
});

mainBoxoffice();

</script>
</body>
</html>
